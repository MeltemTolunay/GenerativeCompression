import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import tensorflow as tf
import tensorflow_hub as hub
import bz2
from PIL import Image
tf.reset_default_graph()

#!/usr/bin/env python3

# Constant to control how often we print when training models
print_every = 100
filename='1'


# Given an image (possibly generated by the GAN)
# this scripts tries to recover its latent vector.

folder = "./test/"
# Choose a random starting point
np.random.seed(0)
zp = tf.Variable(np.random.uniform(low=-1.0, high=1.0, size=(1,512)), dtype=tf.float32)

# Load the image for which we want to recover the latent vector
# and create an appropriate tensor for it
start_img = Image.open(folder + filename+".png")
start_img=start_img.convert('RGB')
start_img.resize((128, 128), Image.ANTIALIAS)
start_img_np = np.array(start_img)/255
fz = tf.Variable(start_img_np, tf.float32)
fz = tf.expand_dims(fz, 0)
fz = tf.cast(fz,tf.float32)

# Define the optimization problem
generator = hub.Module("https://tfhub.dev/google/progan-128/1")
fzp = generator(zp)

loss = tf.reduce_mean(tf.image.ssim(fz, fzp, 1.0))

# Decayed gradient descent
global_step = tf.Variable(0, trainable=False)
starter_learning_rate = 99.0
learning_rate = tf.train.exponential_decay(starter_learning_rate,
                                           global_step,
                                           10000, 0.005)
opt = tf.train.GradientDescentOptimizer(learning_rate)
# Optimize on the variable zp
train = opt.minimize(-loss, var_list=zp, global_step=global_step)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for i in range(10000): # Use more iterations (10000)
  # If we know the original latent vector, we can also compute
  # how far the recovered vector is from it
  _, loss_value, zp_val, eta = sess.run((train, loss, zp, learning_rate))
  if i%100 == 0:
      print("%03d) eta=%03f, loss = %f" % (i, eta, loss_value))
# Save the recovered latent vector
#zp_val = sess.run(zp)
np.save(folder + "zp_rec", zp_val)

# Print out the corresponding image out of the recovered
# latent vector
imgs = sess.run(generator(zp))
imgs = (imgs * 255).astype(np.uint8)
print(imgs.shape)
Image.fromarray(imgs[0]).save(folder + filename+"_rec.png")

img_rec = Image.open(folder+ filename+"_rec.png")
plt.imsave()
plt.imshow(img_rec)
